Задание
Разработайте программный модуль фитнес-трекера, который обрабатывает данные для трех видов тренировок: бега, ходьбы и плавания.
Этот модуль должен:

    рассчитывать результаты тренировки,
    выводить информационное сообщение о результатах тренировки.

Информационное сообщение должно включать такие данные:

    тип тренировки (бег, ходьба или плавание);
    длительность тренировки;
    дистанция, которую преодолел пользователь, в километрах;
    среднюю скорость на дистанции, в км/ч;
    расход энергии, в килокалориях.

Хороший разработчик чётко следует всем требованиям задания. В этом задании уже указаны формулы, которые нужно использовать для расчёта результатов тренировок. Не меняйте их, используйте их точно в таком же виде.
Вам не придётся писать программу с нуля. В репозитории с вашим домашним заданием есть файл main.go. В нём уже описаны некоторые функции и оформлен эскиз будущей программы. Работайте в этом файле и используйте то, что у вас есть, по максимуму.

Исходный код https://github.com/Yandex-Practicum/go-first-floor-sprint-five

Структура программы
Структура Training
В структурах, которые будут описывать разные виды тренировок, применяются одни и те же свойства и методы. Чтобы избежать дублирования кода, логично создать общую структуру Training{}. Поля и методы этой структуры будут справедливы для любого из видов тренировки.
Каждая структура, которая описывает определённый вид тренировки, будет дополнять и расширять общую структуру Training{}.
Все необходимые для расчетов константы будут уже объявлены:

    MInKm — количество метров в одном километре,
    MinsInHour — количество минут в одном часе,
    LenStep — длина одного шага,
    CmInM — количество сантиметров в одном метре,
    CaloriesMeanSpeedMultiplier — множитель средней скорости бега,
    CaloriesMeanSpeedShift — коэффициент изменения средней скорости бега,
    CaloriesWeightMultiplier — коэффициент для расчета потраченных калорий при ходьбе,
    CaloriesSpeedHeightMultiplier — коэффициент для расчета потраченных калорий при ходьбе,
    KmHInMsec — коэффициент для перевода км/ч в м/с,
    SwimmingLenStep — длина одного гребка при плавании,
    SwimmingCaloriesMeanSpeedShift — коэффициент изменения средней скорости при плавании,
    SwimmingCaloriesWeightMultiplier — множитель веса пользователя при плавании.

Поля структуры Training{}

    TrainingType, тип string — описывает вид тренировки (Бег, Ходьба, Плавание);
    Action, тип int — описывает количество шагов при беге и ходьбе или количество гребков при плавании;
    LenStep, тип float64 — описывает длину одного шага или гребка;
    Duration, тип time.Duration — описывает продолжительность тренировки;
    Weight, тип float64 — описывает вес пользователя в килограммах.

Методы структуры Training{}
Метод distance() возвращает дистанцию в километрах, которую преодолел пользователь за время тренировки.
Формула расчёта:

Action * LenStep / MInKm 

Метод meanSpeed() возвращает значение средней скорости движения во время тренировки.
Формула расчёта:

преодолённая_дистанция_за_тренировку_в_км / время_тренировки_в_часах 

Метод Calories() возвращает количество килокалорий, израсходованных во время тренировки.
Логика подсчета калорий для каждого вида тренировки будет своя, поэтому в методе общей структуры Training{} не нужны никакие вычисления. Этот метод будет возвращать просто 0. Вы переопределите этот метод для каждого вида тренировок.
Метод TrainingInfo() возвращает переменную структуры InfoMessage{}. Чтобы заполнить все поля структуры InfoMessage{}, нужно будет вычислить дистанцию, среднюю скорость и количество калорий. Для получения этих значений методы уже определены.
Структура InfoMessage
Эта структура нужна для создания сообщений о проведенной тренировке. У структуры должен быть метод для вывода сообщений на экран.
Поля структуры InfoMessage{}

    TrainingType, тип string — описывает вид тренировки (бег, ходьба, плавание);
    Duration, тип time.Duration — описывает продолжительность тренировки;
    Distance, тип float64 — расстояние, которое преодолел пользователь за время тренировки, в километрах;
    Speed, тип float64 — средняя скорость, с которой двигался пользователь, в км/ч;
    Calories, тип float64 — количество потраченных калорий на тренировке.

Для этой структуры будет переопределен метод String(), который выводит всю информацию о тренировке на экран.
Интерфейс CaloriesCalculator
Этот интерфейс нужен, чтобы было удобно работать со всеми видами тренировок. Интерфейс будет состоять из двух методов:

    Calories() — метод возвращает количество килокалорий, израсходованных во время тренировки.
    TrainingInfo() — возвращает переменную структуры InfoMessage{}.

Получается, вы будете переопределять методы из Training{} для каждого вида тренировок.
Этот интерфейс должны реализовать структуры для бега, ходьбы и плавания, которые вы объявите чуть позже.
Структура Running
Структура описывает тренировку Бег. Так как вы создали общую структуру Training{}, которая справедлива для всех видов тренировок, значит, её нужно встроить в структуру Running{}. Больше никакие поля в структуре Running{} не нужны.
Структура Running{} должна реализовывать интерфейс CaloriesCalculator. В интерфейсе CaloriesCalculator всего два метода: Calories() и TrainingInfo(). Значит, нужно определить эти методы. Так как эти же методы есть и для структуры Training{}, вы переопределяете эти методы для структуры Running{}. Помните, что в методе Calories() вы возвращали просто 0? А теперь вы посчитаете калории для тренировки бег.
Метод Calories() возвращает количество израсходованных калорий при беге.
Формула расчёта:

((CaloriesMeanSpeedMultiplier * средняя_скорость_в_км/ч + CaloriesMeanSpeedShift)
 * вес_спортсмена_в_кг / MInKm * время_тренировки_в_часах * MinInHours) 

Метод TrainingInfo() возвращает переменную структуры InfoMessage{} с информацией о проведённой
тренировке.
Для реализации этого метода для структуры Running{} нужно вернуть вызов такого же метода TrainingInfo(), только для структуры Training{}. Вспомните, как вызывать методы встроенной структуры.
Структура Walking
Структура описывает тренировку «Ходьба». Так как вы создали общую структуру Training{}, которая справедлива для всех видов тренировок, её нужно встроить в структуру Walking{}. Для расчёта израсходованных калорий при ходьбе нужно ещё одно значение — это рост пользователя в сантиметрах. Добавьте поле Height типа float64 в структуру Walking{}.
Структура Walking{} тоже должна реализовывать интерфейс CaloriesCalculator. В интерфейсе CaloriesCalculator всего два метода: Calories() и TrainingInfo() Значит, нужно определить эти методы. Так как эти же методы есть и для структуры Training{}, получается, вы переопределяете эти методы для структуры Walking{}. Помните в методе Calories() вы возвращали просто 0? А теперь вы посчитаете калории для тренировки ходьба.
Метод Calories() возвращает количество израсходованных калорий при ходьбе.
Формула расчёта:

((CaloriesWeightMultiplier * вес_спортсмена_в_кг + (средняя_скорость_в_метрах_в_секунду**2 / рост_в_метрах) * CaloriesSpeedHeightMultiplier * вес_спортсмена_в_кг) * время_тренировки_в_часах * MinsInHour) 

Метод TrainingInfo() возвращает переменную структуры InfoMessage{} с информацией о проведённой
тренировке.
Для реализации этого метода для структуры Walking{} нужно вернуть вызов такого же метода TrainingInfo(), только для структуры Training{}. Вспомните, как вызывать методы встроенной структуры.
Структура Swimming
Структура описывает тренировку Плавание. Так как вы создали общую структуру Training{}, которая справедлива для всех видов тренировок, значит, её нужно встроить в структуру Swimming{}. Для расчета израсходованных калорий при плавании, нужно добавить ещё несколько полей в структуру:

    LengthPool, тип int — длина бассейна в метрах,
    CountPool, тип int — количество пересечений бассейна.

Так как средняя скорость при плавании рассчитывается не так, как для бега и ходьбы, вам нужно будет переопределить метод meanSpeed() из Training{}, только теперь для структуры Swimming{}.
Формула расчёта средней скорости при плавании:

длина_бассейна_в_метрах * CountPool / MInKm / время_тренировки_в_часах 

Структура Swimming{} также должна реализовывать интерфейс CaloriesCalculator. В интерфейсе CaloriesCalculator всего два метода: Calories() и TrainingInfo() Значит, нужно определить эти методы для Swimming{}. Так как эти же методы есть и для структуры Training{}, получается вы переопределяете эти методы для структуры Swimming{}. Помните в методе Calories() вы возвращали просто 0? А теперь вы посчитаете калории для тренировки плавание.
Метод Calories() возвращает количество израсходованных калорий при плавании.
Формула расчета:

(средняя_скорость_в_км/ч + SwimmingCaloriesMeanSpeedShift) * SwimmingCaloriesWeightMultiplier * вес_спортсмена_в_кг * время_тренеровки_в_часах 

Метод TrainingInfo() возвращает переменную структуры InfoMessage{} с информацией о проведённой тренировке.
Для реализации этого метода для структуры Swimming{} нужно полностью переопределить TrainingInfo() с учетом того, как расчитывается средняя скорость для плавания, дистанция и так далее. Реализация TrainingInfo() для Swimming{} будет похожа на реализацию TrainingInfo() для Training{}, но с иcпользованием методов для Swimming{}.
Функция получения данных ReadData()
Чтобы получить данные о тренировке, нужно будет реализовать функцию ReadData(). Это общая функция с одним параметром типа CaloriesCalculator, то есть вашего интерфейса для всех видов тренировок. А значит, вы можете подавать в функцию в качестве аргумента любые структуры, которые реализовывают этот интерфейс.
В самой функции нужно вызывать методы, которые имеют одинаковые имена для всех структур (видов тренировок), но для переменной интерфейса (параметра функции). Так будет вызываться метод, относящийся к структуре, которую вы передали в функцию ReadData() в качестве аргумента.
Чтобы стало понятней, почитайте код в функции main(). Там созданы переменные трех структур: Running{}, Walking{} и Swimming{}. Они подаются в качестве аргументов в функцию ReadData(), хотя у этой функции параметр типа интерфейса CaloriesCalculator.
Вы можете так делать, потому что все три структуры (Running{}, Walking{} и Swimming{}) реализовывают этот интерфейс. Другими словами, для каждой из этих структур есть методы, которые описаны в интерфейсе CaloriesCalculator.
